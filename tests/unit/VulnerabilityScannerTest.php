<?php
/**
 * AtomicEdge Vulnerability Scanner Tests
 *
 * Tests for the AtomicEdge_Vulnerability_Scanner class.
 *
 * @package AtomicEdge\Tests\Unit
 */

namespace AtomicEdge\Tests\Unit;

use AtomicEdge\Tests\TestCase;
use Brain\Monkey\Functions;

/**
 * Vulnerability Scanner Test Suite
 */
class VulnerabilityScannerTest extends TestCase {

	/**
	 * API mock instance.
	 *
	 * @var \AtomicEdge_API
	 */
	private $api;

	/**
	 * Scanner instance.
	 *
	 * @var \AtomicEdge_Vulnerability_Scanner
	 */
	private $scanner;

	/**
	 * Set up before each test.
	 *
	 * @return void
	 */
	protected function set_up() {
		parent::set_up();

		// Create a mock API instance.
		$this->api = $this->getMockBuilder( \AtomicEdge_API::class )
			->disableOriginalConstructor()
			->getMock();

		// Default to connected state.
		$this->api->method( 'is_connected' )->willReturn( true );

		$this->scanner = new \AtomicEdge_Vulnerability_Scanner( $this->api );
	}

	// =========================================================================
	// Availability Tests
	// =========================================================================

	/**
	 * Test is_available returns true when API is connected.
	 */
	public function test_is_available_returns_true_when_connected() {
		$this->assertTrue( $this->scanner->is_available() );
	}

	/**
	 * Test is_available returns false when API is not connected.
	 */
	public function test_is_available_returns_false_when_not_connected() {
		$api = $this->getMockBuilder( \AtomicEdge_API::class )
			->disableOriginalConstructor()
			->getMock();
		$api->method( 'is_connected' )->willReturn( false );

		$scanner = new \AtomicEdge_Vulnerability_Scanner( $api );

		$this->assertFalse( $scanner->is_available() );
	}

	// =========================================================================
	// Run Scan Tests
	// =========================================================================

	/**
	 * Test run_full_scan returns error when not connected.
	 */
	public function test_run_full_scan_returns_error_when_not_connected() {
		$api = $this->getMockBuilder( \AtomicEdge_API::class )
			->disableOriginalConstructor()
			->getMock();
		$api->method( 'is_connected' )->willReturn( false );

		$scanner = new \AtomicEdge_Vulnerability_Scanner( $api );
		$result  = $scanner->run_full_scan();

		$this->assertFalse( $result['success'] );
		$this->assertArrayHasKey( 'error', $result );
		$this->assertStringContainsString( 'API connection', $result['error'] );
	}

	/**
	 * Test run_full_scan returns cached results.
	 */
	public function test_run_full_scan_returns_cached_results() {
		$cached_results = array(
			'success' => true,
			'summary' => array(
				'total_vulnerabilities' => 2,
			),
		);

		$this->set_transient( 'atomicedge_vuln_results', $cached_results );

		$result = $this->scanner->run_full_scan();

		$this->assertEquals( $cached_results, $result );
	}

	/**
	 * Test run_full_scan force refresh bypasses cache.
	 */
	public function test_run_full_scan_force_refresh_bypasses_cache() {
		// Set up cached results.
		$cached_results = array(
			'success' => true,
			'summary' => array(
				'total_vulnerabilities' => 999,
			),
		);
		$this->set_transient( 'atomicedge_vuln_results', $cached_results );

		// Mock WordPress functions for data gathering.
		global $wp_version;
		$wp_version = '6.4.2';

		Functions\when( 'get_plugins' )->justReturn( array() );
		Functions\when( 'wp_get_themes' )->justReturn( array() );
		Functions\when( 'current_time' )->justReturn( '2026-01-06 12:00:00' );

		// Configure API to return fresh results.
		$api_response = array(
			'success' => true,
			'data'    => array(
				'checked_at' => '2026-01-06T12:00:00Z',
				'wordpress'  => array(
					'version'         => '6.4.2',
					'vulnerabilities' => array(),
				),
				'plugins'    => array(),
				'themes'     => array(),
				'summary'    => array(
					'total_vulnerabilities' => 0,
				),
			),
		);

		$this->api->method( 'check_vulnerabilities' )->willReturn( $api_response );

		$result = $this->scanner->run_full_scan( true );

		// Should have fresh results, not cached.
		$this->assertEquals( 0, $result['summary']['total_vulnerabilities'] );
	}

	/**
	 * Test run_full_scan handles API error.
	 */
	public function test_run_full_scan_handles_api_error() {
		// Clear any cached results.
		$this->clear_transients();

		// Mock WordPress functions.
		global $wp_version;
		$wp_version = '6.4.2';

		Functions\when( 'get_plugins' )->justReturn( array() );
		Functions\when( 'wp_get_themes' )->justReturn( array() );

		// Configure API to return error.
		$this->api->method( 'check_vulnerabilities' )->willReturn(
			array(
				'success' => false,
				'error'   => 'API request failed',
			)
		);

		$result = $this->scanner->run_full_scan( true );

		$this->assertFalse( $result['success'] );
		$this->assertEquals( 'API request failed', $result['error'] );
	}

	/**
	 * Test run_full_scan processes successful response.
	 */
	public function test_run_full_scan_processes_successful_response() {
		// Clear any cached results.
		$this->clear_transients();

		// Mock WordPress functions.
		global $wp_version;
		$wp_version = '6.4.2';

		Functions\when( 'get_plugins' )->justReturn(
			array(
				'test-plugin/test-plugin.php' => array(
					'Name'    => 'Test Plugin',
					'Version' => '1.0.0',
				),
			)
		);
		Functions\when( 'wp_get_themes' )->justReturn( array() );
		Functions\when( 'current_time' )->justReturn( '2026-01-06 12:00:00' );
		Functions\when( 'is_plugin_active' )->justReturn( true );

		// Configure API response with vulnerabilities.
		$api_response = array(
			'success' => true,
			'data'    => array(
				'checked_at' => '2026-01-06T12:00:00Z',
				'wordpress'  => array(
					'version'         => '6.4.2',
					'vulnerabilities' => array(),
				),
				'plugins'    => array(
					array(
						'slug'            => 'test-plugin',
						'version'         => '1.0.0',
						'name'            => 'Test Plugin',
						'vulnerabilities' => array(
							array(
								'id'       => 'vuln-1',
								'title'    => 'Test Vulnerability',
								'severity' => 'high',
								'cvss'     => array(
									'score'  => 7.5,
									'rating' => 'high',
								),
							),
						),
					),
				),
				'themes'     => array(),
				'summary'    => array(
					'total_vulnerabilities' => 1,
					'high'                  => 1,
				),
				'attribution' => array(
					'provider' => 'Wordfence Intelligence',
				),
			),
		);

		$this->api->method( 'check_vulnerabilities' )->willReturn( $api_response );

		$result = $this->scanner->run_full_scan( true );

		$this->assertTrue( $result['success'] );
		$this->assertArrayHasKey( 'plugins', $result );
		$this->assertCount( 1, $result['plugins'] );
		$this->assertEquals( 'Test Plugin', $result['plugins'][0]['name'] );
	}

	// =========================================================================
	// Get Results Tests
	// =========================================================================

	/**
	 * Test get_last_results returns empty array when no results exist.
	 */
	public function test_get_last_results_returns_empty_when_no_results() {
		$result = $this->scanner->get_last_results();

		$this->assertIsArray( $result );
		$this->assertEmpty( $result );
	}

	/**
	 * Test get_last_results returns stored results.
	 */
	public function test_get_last_results_returns_stored_results() {
		$stored_results = array(
			'success' => true,
			'summary' => array(
				'total_vulnerabilities' => 3,
			),
		);

		$this->set_option( 'atomicedge_vulnerability_results', $stored_results );

		$result = $this->scanner->get_last_results();

		$this->assertEquals( $stored_results, $result );
	}

	/**
	 * Test get_last_scan_time returns null when never scanned.
	 */
	public function test_get_last_scan_time_returns_null_when_never_scanned() {
		$result = $this->scanner->get_last_scan_time();

		$this->assertNull( $result );
	}

	/**
	 * Test get_last_scan_time returns timestamp when scanned.
	 */
	public function test_get_last_scan_time_returns_timestamp_when_scanned() {
		$scan_time = '2026-01-06 12:00:00';
		$this->set_option( 'atomicedge_vulnerability_last_scan', $scan_time );

		$result = $this->scanner->get_last_scan_time();

		$this->assertEquals( $scan_time, $result );
	}

	// =========================================================================
	// Summary Tests
	// =========================================================================

	/**
	 * Test get_vulnerability_count returns zero when no results.
	 */
	public function test_get_vulnerability_count_returns_zero_when_no_results() {
		$result = $this->scanner->get_vulnerability_count();

		$this->assertEquals( 0, $result );
	}

	/**
	 * Test get_vulnerability_count returns correct count.
	 */
	public function test_get_vulnerability_count_returns_correct_count() {
		$this->set_option(
			'atomicedge_vulnerability_results',
			array(
				'success' => true,
				'summary' => array(
					'total_vulnerabilities' => 5,
				),
			)
		);

		$result = $this->scanner->get_vulnerability_count();

		$this->assertEquals( 5, $result );
	}

	// =========================================================================
	// Helper Tests
	// =========================================================================

	/**
	 * Test clear_cache removes cached results.
	 */
	public function test_clear_cache_removes_transient() {
		$this->set_transient( 'atomicedge_vuln_results', array( 'test' => true ) );

		$this->scanner->clear_cache();

		$cached = $this->get_transient( 'atomicedge_vuln_results' );
		$this->assertFalse( $cached );
	}
}
