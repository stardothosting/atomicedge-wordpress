<?php
/**
 * AtomicEdge Vulnerability Scanner
 *
 * Checks installed plugins and themes against the AtomicEdge vulnerability database.
 * Vulnerability data is provided by Wordfence Intelligence and requires an AtomicEdge
 * API connection to access.
 *
 * @package AtomicEdge
 */

// Prevent direct access.
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Class AtomicEdge_Vulnerability_Scanner
 *
 * Scans installed plugins and themes for known vulnerabilities via the AtomicEdge API.
 */
class AtomicEdge_Vulnerability_Scanner {

	/**
	 * API instance.
	 *
	 * @var AtomicEdge_API
	 */
	private $api;

	/**
	 * Cache duration for vulnerability data (1 hour).
	 *
	 * @var int
	 */
	const CACHE_DURATION = HOUR_IN_SECONDS;

	/**
	 * Constructor.
	 *
	 * @param AtomicEdge_API $api API instance.
	 */
	public function __construct( $api ) {
		$this->api = $api;
	}

	/**
	 * Check if vulnerability scanning is available.
	 *
	 * Requires AtomicEdge API connection.
	 *
	 * @return bool True if API is connected.
	 */
	public function is_available() {
		return $this->api->is_connected();
	}

	/**
	 * Run a full vulnerability scan on all installed plugins and themes.
	 *
	 * @param bool $force_refresh Force refresh of cached data.
	 * @return array Scan results.
	 */
	public function run_full_scan( $force_refresh = false ) {
		if ( ! $this->is_available() ) {
			return array(
				'error'   => __( 'Vulnerability scanning requires an AtomicEdge API connection. Please connect your site in the Settings page.', 'atomicedge' ),
				'success' => false,
			);
		}

		// Check for cached results unless force refresh.
		if ( ! $force_refresh ) {
			$cached = get_transient( 'atomicedge_vuln_results' );
			if ( false !== $cached ) {
				return $cached;
			}
		}

		// Gather WordPress installation data.
		$scan_data = $this->gather_installation_data();

		// Send to AtomicEdge API for vulnerability checking.
		$response = $this->api->check_vulnerabilities( $scan_data );

		if ( ! $response['success'] ) {
			return array(
				'error'   => isset( $response['error'] ) ? $response['error'] : __( 'Failed to check vulnerabilities.', 'atomicedge' ),
				'success' => false,
			);
		}

		$results = $this->process_api_response( $response['data'] );

		// Cache results.
		set_transient( 'atomicedge_vuln_results', $results, self::CACHE_DURATION );

		// Save to options for persistence.
		update_option( 'atomicedge_vulnerability_results', $results );
		update_option( 'atomicedge_vulnerability_last_scan', current_time( 'mysql' ) );

		AtomicEdge::log( 'Vulnerability scan completed', $results['summary'] );

		return $results;
	}

	/**
	 * Gather WordPress installation data for vulnerability scanning.
	 *
	 * @return array Installation data.
	 */
	private function gather_installation_data() {
		global $wp_version;

		$data = array(
			'wordpress_version' => $wp_version,
			'plugins'           => array(),
			'themes'            => array(),
		);

		// Gather plugin data.
		if ( ! function_exists( 'get_plugins' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}

		$plugins = get_plugins();
		foreach ( $plugins as $plugin_file => $plugin_data ) {
			$slug = $this->get_plugin_slug( $plugin_file );

			if ( ! empty( $slug ) && ! empty( $plugin_data['Version'] ) ) {
				$data['plugins'][] = array(
					'slug'    => $slug,
					'version' => $plugin_data['Version'],
					'name'    => $plugin_data['Name'],
				);
			}
		}

		// Gather theme data.
		$themes = wp_get_themes();
		foreach ( $themes as $slug => $theme ) {
			$version = $theme->get( 'Version' );
			if ( ! empty( $version ) ) {
				$data['themes'][] = array(
					'slug'    => $slug,
					'version' => $version,
					'name'    => $theme->get( 'Name' ),
				);
			}
		}

		return $data;
	}

	/**
	 * Process API response into display-ready format.
	 *
	 * @param array $api_data API response data.
	 * @return array Processed results.
	 */
	private function process_api_response( $api_data ) {
		$results = array(
			'started_at'   => isset( $api_data['checked_at'] ) ? $api_data['checked_at'] : current_time( 'mysql' ),
			'completed_at' => current_time( 'mysql' ),
			'wordpress'    => array(),
			'plugins'      => array(),
			'themes'       => array(),
			'summary'      => array(),
			'attribution'  => isset( $api_data['attribution'] ) ? $api_data['attribution'] : array(),
			'success'      => true,
		);

		// Process WordPress core vulnerabilities.
		if ( isset( $api_data['wordpress'] ) && ! empty( $api_data['wordpress']['vulnerabilities'] ) ) {
			global $wp_version;
			$results['wordpress'] = array(
				'name'            => 'WordPress',
				'version'         => $wp_version,
				'vulnerabilities' => $this->enhance_vulnerabilities( $api_data['wordpress']['vulnerabilities'] ),
			);
		}

		// Process plugin vulnerabilities.
		if ( isset( $api_data['plugins'] ) && is_array( $api_data['plugins'] ) ) {
			foreach ( $api_data['plugins'] as $plugin ) {
				if ( ! empty( $plugin['vulnerabilities'] ) ) {
					$results['plugins'][] = array(
						'name'            => isset( $plugin['name'] ) ? $plugin['name'] : $plugin['slug'],
						'slug'            => $plugin['slug'],
						'version'         => $plugin['version'],
						'active'          => $this->is_plugin_active( $plugin['slug'] ),
						'vulnerabilities' => $this->enhance_vulnerabilities( $plugin['vulnerabilities'] ),
					);
				}
			}
		}

		// Process theme vulnerabilities.
		if ( isset( $api_data['themes'] ) && is_array( $api_data['themes'] ) ) {
			foreach ( $api_data['themes'] as $theme ) {
				if ( ! empty( $theme['vulnerabilities'] ) ) {
					$results['themes'][] = array(
						'name'            => isset( $theme['name'] ) ? $theme['name'] : $theme['slug'],
						'slug'            => $theme['slug'],
						'version'         => $theme['version'],
						'active'          => ( get_stylesheet() === $theme['slug'] ),
						'vulnerabilities' => $this->enhance_vulnerabilities( $theme['vulnerabilities'] ),
					);
				}
			}
		}

		// Copy summary from API or generate.
		if ( isset( $api_data['summary'] ) ) {
			$results['summary'] = $api_data['summary'];
		} else {
			$results['summary'] = $this->generate_summary( $results );
		}

		return $results;
	}

	/**
	 * Enhance vulnerability data with additional UI-friendly fields.
	 *
	 * @param array $vulnerabilities Raw vulnerability data.
	 * @return array Enhanced vulnerabilities.
	 */
	private function enhance_vulnerabilities( $vulnerabilities ) {
		$enhanced = array();

		foreach ( $vulnerabilities as $vuln ) {
			$enhanced_vuln = array(
				'id'               => isset( $vuln['id'] ) ? $vuln['id'] : '',
				'title'            => isset( $vuln['title'] ) ? $vuln['title'] : __( 'Unknown vulnerability', 'atomicedge' ),
				'description'      => isset( $vuln['description'] ) ? $vuln['description'] : '',
				'severity'         => isset( $vuln['severity'] ) ? $vuln['severity'] : 'medium',
				'severity_class'   => $this->get_severity_class( isset( $vuln['severity'] ) ? $vuln['severity'] : 'medium' ),
				'cvss'             => isset( $vuln['cvss'] ) ? $vuln['cvss'] : null,
				'cve'              => isset( $vuln['cve'] ) ? $vuln['cve'] : null,
				'cve_link'         => isset( $vuln['cve_link'] ) ? $vuln['cve_link'] : null,
				'references'       => isset( $vuln['references'] ) ? $vuln['references'] : array(),
				'patched'          => isset( $vuln['patched'] ) ? $vuln['patched'] : false,
				'patched_versions' => isset( $vuln['patched_versions'] ) ? $vuln['patched_versions'] : array(),
				'remediation'      => isset( $vuln['remediation'] ) ? $vuln['remediation'] : null,
				'published'        => isset( $vuln['published'] ) ? $vuln['published'] : null,
			);

			// Format patched versions for display.
			if ( ! empty( $enhanced_vuln['patched_versions'] ) ) {
				$enhanced_vuln['fix_available'] = true;
				$enhanced_vuln['fix_version']   = implode( ', ', array_slice( $enhanced_vuln['patched_versions'], 0, 3 ) );
			} else {
				$enhanced_vuln['fix_available'] = false;
				$enhanced_vuln['fix_version']   = null;
			}

			$enhanced[] = $enhanced_vuln;
		}

		return $enhanced;
	}

	/**
	 * Get CSS class for severity level.
	 *
	 * @param string $severity Severity level.
	 * @return string CSS class.
	 */
	private function get_severity_class( $severity ) {
		$classes = array(
			'critical' => 'atomicedge-severity-critical',
			'high'     => 'atomicedge-severity-high',
			'medium'   => 'atomicedge-severity-medium',
			'low'      => 'atomicedge-severity-low',
		);

		return isset( $classes[ $severity ] ) ? $classes[ $severity ] : 'atomicedge-severity-medium';
	}

	/**
	 * Generate summary statistics.
	 *
	 * @param array $results Processed results.
	 * @return array Summary.
	 */
	private function generate_summary( $results ) {
		$summary = array(
			'total_vulnerabilities' => 0,
			'critical'              => 0,
			'high'                  => 0,
			'medium'                => 0,
			'low'                   => 0,
			'wordpress_vulnerable'  => false,
			'plugins_vulnerable'    => 0,
			'themes_vulnerable'     => 0,
		);

		// Count WordPress vulnerabilities.
		if ( ! empty( $results['wordpress']['vulnerabilities'] ) ) {
			$summary['wordpress_vulnerable'] = true;
			foreach ( $results['wordpress']['vulnerabilities'] as $vuln ) {
				++$summary['total_vulnerabilities'];
				$severity = isset( $vuln['severity'] ) ? $vuln['severity'] : 'medium';
				if ( isset( $summary[ $severity ] ) ) {
					++$summary[ $severity ];
				}
			}
		}

		// Count plugin vulnerabilities.
		foreach ( $results['plugins'] as $plugin ) {
			if ( ! empty( $plugin['vulnerabilities'] ) ) {
				++$summary['plugins_vulnerable'];
				foreach ( $plugin['vulnerabilities'] as $vuln ) {
					++$summary['total_vulnerabilities'];
					$severity = isset( $vuln['severity'] ) ? $vuln['severity'] : 'medium';
					if ( isset( $summary[ $severity ] ) ) {
						++$summary[ $severity ];
					}
				}
			}
		}

		// Count theme vulnerabilities.
		foreach ( $results['themes'] as $theme ) {
			if ( ! empty( $theme['vulnerabilities'] ) ) {
				++$summary['themes_vulnerable'];
				foreach ( $theme['vulnerabilities'] as $vuln ) {
					++$summary['total_vulnerabilities'];
					$severity = isset( $vuln['severity'] ) ? $vuln['severity'] : 'medium';
					if ( isset( $summary[ $severity ] ) ) {
						++$summary[ $severity ];
					}
				}
			}
		}

		return $summary;
	}

	/**
	 * Check if a plugin is active.
	 *
	 * @param string $slug Plugin slug.
	 * @return bool True if active.
	 */
	private function is_plugin_active( $slug ) {
		$active_plugins = get_option( 'active_plugins', array() );

		foreach ( $active_plugins as $plugin_file ) {
			if ( 0 === strpos( $plugin_file, $slug . '/' ) || $plugin_file === $slug . '.php' ) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Get plugin slug from plugin file path.
	 *
	 * @param string $plugin_file Plugin file path (e.g., "akismet/akismet.php").
	 * @return string Plugin slug.
	 */
	private function get_plugin_slug( $plugin_file ) {
		// Handle single-file plugins.
		if ( false === strpos( $plugin_file, '/' ) ) {
			return pathinfo( $plugin_file, PATHINFO_FILENAME );
		}

		// Extract directory name as slug.
		$parts = explode( '/', $plugin_file );
		return $parts[0];
	}

	/**
	 * Get last vulnerability scan results.
	 *
	 * @return array Scan results.
	 */
	public function get_last_results() {
		return get_option( 'atomicedge_vulnerability_results', array() );
	}

	/**
	 * Get last vulnerability scan timestamp.
	 *
	 * @return string|null Timestamp or null if never scanned.
	 */
	public function get_last_scan_time() {
		$time = get_option( 'atomicedge_vulnerability_last_scan', null );
		return $time ? $time : null;
	}

	/**
	 * Get total vulnerability count from last scan.
	 *
	 * @return int Number of vulnerabilities found.
	 */
	public function get_vulnerability_count() {
		$results = $this->get_last_results();
		if ( isset( $results['summary']['total_vulnerabilities'] ) ) {
			return (int) $results['summary']['total_vulnerabilities'];
		}
		return 0;
	}

	/**
	 * Clear all cached vulnerability data.
	 *
	 * @return void
	 */
	public function clear_cache() {
		delete_transient( 'atomicedge_vuln_results' );
	}
}
